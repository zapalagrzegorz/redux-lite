{"version":3,"file":"main.js","mappings":"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","sources":["webpack://redux-light/./src/store.js","webpack://redux-light/webpack/bootstrap","webpack://redux-light/webpack/runtime/define property getters","webpack://redux-light/webpack/runtime/hasOwnProperty shorthand","webpack://redux-light/webpack/runtime/make namespace object","webpack://redux-light/./src/index.jsx"],"sourcesContent":["// Using ES6 class syntax, create a new class, Store, that will represent our global application state. The Store#constructor function will take a single function as an argument, rootReducer. The constructor function should define instance variables to store the rootReducer and the global state (an empty object for now). We also need to have a way to read from the state. Define a Store#getState function that returns the state instance variable.\n\n// Note: Since we want to control how the state can be modified, we want to make sure we don't return the actual state object, otherwise we could inadvertently modify it directly. Instead, return a copy of this.state using Object.assign.\n\n// Another Quick Note: Object.assign only creates a \"shallow\" copy of our state object. That means that if our state has any nested objects or arrays, the original and the copy will still point to the same references. We'll ignore this for now, but come back here at the end of the project and re-write this function to return a \"deep\" copy of the state!\n\nexport default class Store {\n  constructor(rootReducer) {\n    this.rootReducer = rootReducer;\n    this.subscriptions = [];\n    this.state = this.rootReducer(\n      { users: undefined, goods: undefined },\n      '',\n      this.subscriptions\n    );\n    // warn\n    // this.getState = this.getState.bind(this);\n  }\n\n  subscribe(subscriptionCallback) {\n    this.subscriptions.push(subscriptionCallback);\n  }\n  getState() {\n    return { ...this.state };\n  }\n\n  dispatch(action) {\n    this.state = this.rootReducer(this.getState(), action, this.subscriptions);\n  }\n}\n\nconst addUserActionCreator = (payload) => ({\n  type: 'addUser',\n  payload: 'SZ',\n});\n\nconst removeLastUserActionCreator = () => ({\n  type: 'removeLastUser',\n});\n\nconst myInconsequentialActionCreator = () => ({\n  type: 'a type no one cares about',\n  data: {\n    thisThing: 'will not get used anyway',\n  },\n});\n\n// users: ['GZ', 'MZ'],\n//       goods: ['bananas', 'breads'],\nconst userReducer = (prevState = ['GZ', 'MZ'], { type, payload }) => {\n  if (type == 'addUser') {\n    return [...prevState, payload];\n  } else if (type == 'removeLastUser') {\n    return [...prevState].slice(0, -1);\n  } else {\n    return prevState;\n  }\n};\nconst goodsReducer = (prevState = ['bananas', 'breads'], { type, payload }) => {\n  if (type == 'addGoods') {\n    return [...prevState, payload];\n  } else {\n    return prevState;\n  }\n};\n\nconst myReducers = {\n  users: userReducer,\n  goods: goodsReducer,\n};\n\n// * RootReducer zawiera wszystkie cząstkowe reducery. Przyjmuje dowolną akcję i odpala\n// * wszystkie reducery pytając czy zmieni ona wartość stanu.\nconst combineReducers = (reducers) => {\n  return (prevState, action, subscriptions) => {\n    //  przejdź przez wszystkie klucze i wartosci dotychczasowego stanu\n    // za każdą iteracją: twórz nową wartość stanu w oparciu o cząstkowy reducer\n    // [ z listy dostępnych szczątkowych reducerów wybierz ten, który odpowiada za wartość wg klucza ze stanu]\n    // patrz lista reducerów - reducers\n    //  (reducers[key])\n    // przekaż mu dotychczasową wartość oraz akcję\n    // jeżeli akcja nic nie robi, to zwróci dotychczasową wartość!\n    //\n    let newState = {};\n    let stateChanged = false;\n\n    for (const stateSliceKey in prevState) {\n      const prevStateSliceValue = prevState[stateSliceKey];\n\n      // appropriate reducer\n      const sliceReducer = reducers[stateSliceKey];\n\n      // each slice has its own appropriate reducer\n      //\n      const newStateSliceValue = sliceReducer(prevStateSliceValue, action);\n      // if state doesn't change, returns the very same slice\n\n      // state hasn't changed - references are the same\n      if (prevStateSliceValue !== newStateSliceValue) {\n        stateChanged = true;\n      }\n      newState = { ...newState, [stateSliceKey]: newStateSliceValue };\n    }\n    if (stateChanged) {\n      subscriptions.forEach((subscriptionCallback) =>\n        subscriptionCallback(newState)\n      );\n    }\n    return newState;\n\n    // problem miałem z pętlą\n    // jakbym nie mógł puścić pętli po wszystkich częściach stanu\n    // człowiek chce wykonać od razu idź do tego reducera\n    // komputer tego nie wie. On umie robić pętle i robi to szybko\n  };\n};\n\nconst myRootReducer = combineReducers(myReducers);\n\nconst store = new Store(myRootReducer);\n\nstore.getState();\n\nconst announceStateChange = (nextState) => {\n  console.log(\n    `That action changed the state! Users are now ${nextState.users}`\n  );\n};\n\nstore.subscribe(announceStateChange);\n\nstore.dispatch(addUserActionCreator());\nstore.dispatch(myInconsequentialActionCreator());\nstore.dispatch(removeLastUserActionCreator());\nstore.dispatch(myInconsequentialActionCreator());\n\nstore.getState();\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// var let = qw;\nimport './store';\n"],"names":["Store","constructor","rootReducer","subscriptions","state","users","undefined","goods","subscribe","subscriptionCallback","push","getState","dispatch","action","addUserActionCreator","payload","type","removeLastUserActionCreator","myInconsequentialActionCreator","data","thisThing","userReducer","prevState","slice","goodsReducer","myReducers","combineReducers","reducers","newState","stateChanged","stateSliceKey","prevStateSliceValue","sliceReducer","newStateSliceValue","forEach","myRootReducer","store","announceStateChange","nextState","console","log"],"sourceRoot":""}